import nltk
from nltk.sentiment import SentimentIntensityAnalyzer
import spacy
from spacy import displacy
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Embedding, LSTM
import pyttsx3
import speech_recognition as sr
import tkinter as tk
from tkinter import messagebox

# Initialize the NLP engine
nlp = spacy.load("en_core_web_sm")

# Initialize the sentiment analysis engine
sia = SentimentIntensityAnalyzer() 

# Initialize the entity recognition engine
ner = spacy.load("en_core_web_sm")
 
# Initialize the contextual awareness engine
context = tf.keras.models.Sequential([
    tf.keras.layers.Embedding(input_dim=10000, output_dim=128, input_length=100),
    tf.keras.layers.LSTM(128, dropout=0.2),
    tf.keras.layers.Dense(64, activation="relu"),
    tf.keras.layers.Dense(1, activation="sigmoid")
])

# Initialize the personalization engine
personalization = tf.keras.models.Sequential([
    tf.keras.layers.Dense(64, activation="relu", input_shape=(100,)),
    tf.keras.layers.Dense(32, activation="relu"),
    tf.keras.layers.Dense(1, activation="sigmoid")
])

# Define the user interface
def user_interface():
    root = tk.Tk()
    root.title("Conversational AI")
    label = tk.Label(root, text="Hello! How can I assist you today?")
    label.pack()
    entry = tk.Entry(root)
    entry.pack()
    button = tk.Button(root, text="Submit", command=lambda: process_input(entry.get()))
    button.pack()
    root.mainloop()

# Define the voice input function
def voice_input():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Please say something:")
        audio = r.listen(source)
        try:
            voice_input = r.recognize_google(audio)
            return voice_input
        except sr.UnknownValueError:
            print("Sorry, I didn't catch that.")
            return None

# Define the text-to-speech function
def text_to_speech(text):
    engine = pyttsx3.init()
    engine.say(text)
    engine.runAndWait()

# Define the process input function
def process_input(input_text):
    # Preprocess the input text
    input_text = nltk.word_tokenize(input_text)
    input_text = [word.lower() for word in input_text]
    
    # Analyze the sentiment of the input text
    sentiment = sia.polarity_scores(input_text)
    
    # Recognize entities in the input text
    entities = ner(input_text)
    
    # Maintain context
    context_input = tf.keras.preprocessing.sequence.pad_sequences([input_text], maxlen=100)
    context_output = context.predict(context_input)
    
    # Personalize the response
    personalization_input = tf.keras.preprocessing.sequence.pad_sequences([input_text], maxlen=100)
    personalization_output = personalization.predict(personalization_input)
    
    # Generate a response
    response = "I'm not sure I understand what you mean."
    if sentiment["compound"] > 0.5:
        response = "I'm happy to help you with that!"
    elif sentiment["compound"] < -0.5:
        response = "I apologize if I've caused any inconvenience."
    
    # Play the audio response
    text_to_speech(response)

# Define the main function
def main():
    while True:
        voice_input = voice_input()
        if voice_input is not None:
            process_input(voice_input)

# Run the main function
if __name__ == '__main__':
    main()

# --- End of JADE Code ---

import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from cryptography.fernet import Fernet
import os
import psutil
import time
import re
import json

class SmartContractAnalyzer:
    def __init__(self):
        pass

    def analyze_contract(self, contract_code: str):
        # Analyze the code of the smart contract
        # For demonstration purposes, we'll use a simple regular expression to detect potential vulnerabilities
        vulnerabilities = []
        if re.search(r"reentrancy", contract_code):
            vulnerabilities.append("Reentrancy vulnerability detected")
        if re.search(r"unsecured function", contract_code):
            vulnerabilities.append("Unsecured function detected")
        return vulnerabilities

class IntelligentPredictionModule:
    def __init__(self):
        pass

    def make_prediction(self, vulnerabilities: list):
        # Make intelligent predictions and recommendations
        # For demonstration purposes, we'll use a simple random forest classifier
        X = np.array(vulnerabilities)
        y = np.array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1])
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        classifier = RandomForestClassifier()
        classifier.fit(X_train, y_train)
        predictions = classifier.predict(X_test)
        accuracy = accuracy_score(y_test, predictions)
        print(f"Prediction accuracy: {accuracy:.2f}")
        return predictions

class BlockchainIntegrationModule:
    def __init__(self):
        pass

    def integrate_with_blockchain(self, contract_code: str):
        # Integrate the Aegis Protocol with blockchain technologies
        # For demonstration purposes, we'll use a simple JSON file to simulate blockchain data
        blockchain_data = json.load(open("blockchain_data.json"))
        contract_address = blockchain_data["contract_address"]
        contract_balance = blockchain_data["contract_balance"]
        print(f"Contract address: {contract_address}")
        print(f"Contract balance: {contract_balance}")

class AegisProtocol:
    def __init__(self):
        self.sca = SmartContractAnalyzer()
        self.ipm = IntelligentPredictionModule()
        self.bim = BlockchainIntegrationModule()

    def analyze_contract(self, contract_code: str):
        # Analyze the code of the smart contract
        vulnerabilities = self.sca.analyze_contract(contract_code)
        return vulnerabilities

    def make_prediction(self, vulnerabilities: list):
        # Make intelligent predictions and recommendations
        predictions = self.ipm.make_prediction(vulnerabilities)
        return predictions

    def integrate_with_blockchain(self, contract_code: str):
        # Integrate the Aegis Protocol with blockchain technologies
        self.bim.integrate_with_blockchain(contract_code)

# Example usage
aegis_protocol = AegisProtocol()
contract_code = """
pragma solidity ^0.8.0;

contract MyContract {
    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, "Only the owner can transfer ownership");
        owner = newOwner;
    }
}
"""
vulnerabilities = aegis_protocol.analyze_contract(contract_code)
predictions = aegis_protocol.make_prediction(vulnerabilities)
aegis_protocol.integrate_with_blockchain(contract_code)

# --- End of AEGIS Protocol Code ---